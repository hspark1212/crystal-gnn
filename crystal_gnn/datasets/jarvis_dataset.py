from typing import Dict, Any
import os
import pandas as pd
from tqdm import tqdm

from jarvis.core.atoms import Atoms

import dgl
from dgl.data import DGLDataset
import torch


from crystal_gnn.datasets.utils_jarvis import (
    jarvis_atoms_to_dgl_graph,
    compute_bond_cosines,
)


class JarvisDataset(DGLDataset):
    def __init__(
        self,
        database_name: str,
        target: str,
        split: str,
        compute_line_graph: bool = True,
        data_dir: str = "./crystal_gnn/data/",
        neighbor_strategy: str = "k-nearest",
        cutoff: float = 8.0,
        max_neighbors: int = 12,
        use_canonize: bool = True,
    ) -> None:
        """Generate JarvisDataset.

        Args:
            database_name (str): name of the database in JARVIS
            target (str): target property in the database
            split (str): split of the dataset, one of train, val, test
            compute_line_graph (bool, optional): compute line graph. Defaults to False.
            data_dir (str, optional): data directory containing the dataset.
            neighbor_strategy (str, optional): neighbor strategy. Defaults to "k-nearest".
            cutoff (float, optional): cutoff distance. Defaults to 8.0.
            max_neighbors (int, optional): maximum number of neighbors. Defaults to 12.
            use_canonize (bool, optional): whether to use canonize. Defaults to True.
        """
        super(JarvisDataset, self).__init__(name=database_name)
        assert split in [
            "train",
            "val",
            "test",
        ], "split must be one of train, val, test"
        self.compute_line_graph = compute_line_graph
        # read dataset.csv generated by prepare_data.py
        dataset_path = os.path.join(
            data_dir, target, f"{split}-{database_name}-{target}.csv"
        )
        if not os.path.exists(dataset_path):
            raise FileNotFoundError(f"{dataset_path} does not exist")
        dataset = pd.read_csv(dataset_path)
        # load graphs and line graphs if they exist
        path_graph = os.path.join(
            data_dir, target, f"{split}-{database_name}-{target}-graph.pt"
        )
        path_line_graph = os.path.join(
            data_dir, target, f"{split}-{database_name}-{target}-line_graph.pt"
        )
        if (
            compute_line_graph
            and os.path.exists(path_graph)
            and os.path.exists(path_line_graph)
        ):
            self.graphs = dgl.load_graphs(path_graph)[0]
            self.line_graphs = dgl.load_graphs(path_line_graph)[0]
            print(f"successfully load graphs and line graphs for {split} dataset")
        elif not compute_line_graph and os.path.exists(path_graph):
            self.graphs = dgl.load_graphs(path_graph)[0]
            print(f"successfully load graphs for {split} dataset")
        else:
            # generate graphs and line graphs
            # convert atoms to Jarvis Atoms
            atoms_list = list(
                dataset["atoms"].apply(lambda x: Atoms.from_dict(eval(x)))
            )
            # convert Jarvis Atoms to DGLGraph
            graphs = []
            line_graphs = []
            for atoms in tqdm(atoms_list):
                graph = jarvis_atoms_to_dgl_graph(
                    atoms,
                    neighbor_strategy,
                    cutoff,
                    max_neighbors,
                    use_canonize,
                )
                graph.apply_edges(
                    lambda edges: {
                        "distance": torch.norm(edges.data["coord_diff"], dim=1)
                    }
                )
                graphs.append(graph)
                if compute_line_graph:
                    line_graph = graph.line_graph(shared=True)
                    line_graph.apply_edges(compute_bond_cosines)
                    line_graphs.append(line_graph)
            # save graphs and line graphs
            dgl.save_graphs(path_graph, graphs)
            print(f"successfully save graphs for {split} dataset")
            if compute_line_graph:
                dgl.save_graphs(path_line_graph, line_graphs)
                print(f"successfully save line graphs for {split} dataset")
            self.graphs = graphs
            self.line_graphs = line_graphs
        # get target
        self.targets = list(dataset[target])

    def __len__(self) -> int:
        return len(self.graphs)

    def __getitem__(self, index: int) -> Dict[str, Any]:
        data = dict()
        graph = self.graphs[index]
        target = self.targets[index]
        data.update({"graph": graph, "target": target})
        if self.compute_line_graph:
            line_graph = self.line_graphs[index]
            data.update({"line_graph": line_graph})

        return data

    @staticmethod
    def collate_fn(batch: Dict[str, Any]) -> Dict[str, Any]:
        """batch collate function for JarvisDataset."""
        keys = set([key for b in batch for key in b.keys()])
        dict_batch = {k: [dic[k] if k in dic else None for dic in batch] for k in keys}
        # get batch graph
        dict_batch["graph"] = dgl.batch(dict_batch["graph"])
        # get batch line graph
        if "line_graph" in keys:
            dict_batch["line_graph"] = dgl.batch(dict_batch["line_graph"])
        # get batch target
        dict_batch["target"] = torch.tensor(dict_batch["target"])
        return dict_batch
